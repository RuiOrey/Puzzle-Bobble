<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR puzzle bobble</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
</style>
</head>

<body>

</body>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="webvr-boilerplate/node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="webvr-boilerplate/node_modules/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="webvr-boilerplate/node_modules/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="webvr-boilerplate/node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="webvr-boilerplate/node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="webvr-boilerplate/build/webvr-manager.js"></script>


<script src="webvr-boilerplate/node_modules/three/examples/js/loaders/OBJLoader.js"></script>


<script>


  var analyser;

  var mesh, skybox, ball;

  var mouseX,mouseY;

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var ballPlayer, pointer;

  var paramsGame = {

    demo : false,

    particles : 2000,

    radius : 5000,

    ballRadius : 50

  };

  var particles = [];

  var directionalLight;

  var light;
  var line;
  var linegeometry = new THREE.Geometry();
  var linematerial = new THREE.LineDashedMaterial({
    color: 0x000011,
    fog: true,
    linewidth:0.3
  });

  function randomSpherePoint(x0,y0,z0,radius){
    var u = Math.random();
    var v = Math.random();
    var theta = 2 * Math.PI * u;
    var phi = Math.acos(2 * v - 1);
    var x = x0 + (radius * Math.sin(phi) * Math.cos(theta));
    var y = y0 + (radius * Math.sin(phi) * Math.sin(theta));
    var z = z0 + (radius * Math.cos(phi));
    return {x,y,z};
  }

// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);
controls.standing = true;

// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(window.innerWidth, window.innerHeight);


// Add a repeating grid as a skybox.

var loader = new THREE.TextureLoader();
loader.load('models/textures/sky.png', onTextureLoaded);


  var onProgress = function ( xhr ) {
    if ( xhr.lengthComputable ) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log( Math.round(percentComplete, 2) + '% downloaded' );
    }
  };
  var onError = function ( xhr ) {
  };

function onTextureLoaded(texture) {

  /*
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxSize, boxSize);

  var geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });

  // Align the skybox to the floor (which is at y=0).
  skybox = new THREE.Mesh(geometry, material);
  skybox.position.y = boxSize/2;
  scene.add(skybox);

  */

  /*----------------------

   SKYBOX INIT

   ----------------------*/




  var textureEquirec = texture.clone();

  textureEquirec.needsUpdate = true;

  //textureEquirec = THREE.ImageUtils.loadTexture( "assets/living-room-panorama3-0.jpg" );

  textureEquirec.format = THREE.RGBAFormat;

  textureEquirec.mapping = THREE.EquirectangularReflectionMapping;

  textureEquirec.magFilter = THREE.LinearFilter;

  textureEquirec.minFilter = THREE.LinearMipMapLinearFilter;

  textureEquirec.wrapS = THREE.MirroredRepeatWrapping;
  textureEquirec.wrapT = THREE.MirroredRepeatWrapping;

  textureEquirec.repeat.set( 6, 6 );

  var equirectShader = THREE.ShaderLib[ "equirect" ];

  var equirectMaterial = new THREE.MeshPhongMaterial( {

    fragmentShader: equirectShader.fragmentShader,

    vertexShader: equirectShader.vertexShader,

    //uniforms: equirectShader.uniforms,

    depthWrite: false,

    map:textureEquirec,

    side: THREE.BackSide

  } );

  //equirectMaterial.uniforms[ "tEquirect" ].value = textureEquirec;

  var geometry = new THREE.SphereGeometry( 3000, 30, 30 );

  skybox = new THREE.Mesh( geometry, equirectMaterial );

  scene.add( skybox );

  var material = new THREE.MeshPhongMaterial( { map:texture } );

  geometry = new THREE.BoxGeometry( 70, 2, 2 );

  var ballTop  = new THREE.Mesh( geometry, material );

  ballTop.position.set(0.0, controls.userHeight + 45, -120.0);

  scene.add(ballTop);

  geometry = new THREE.BoxGeometry( 2, 85, 2 );

  var ballSide  = new THREE.Mesh( geometry, material );

  var ballLeft = ballSide.clone();

  ballLeft.position.set(35, controls.userHeight + 45 - 41.5, -120.0);

  scene.add(ballLeft);

  var ballRight = ballSide.clone();

  ballRight.position.set(-35, controls.userHeight + 45 - 41.5, -120.0);

  scene.add(ballRight);

  var material = new THREE.MeshPhongMaterial( { map:textureEquirec } );
  // Create 3D objects.
  var geometry = new THREE.SphereGeometry(3, 100, 100);
  //var material = new THREE.MeshPhongMaterial();
  ballPlayer = new THREE.Mesh(geometry, material);

// Position cube mesh to be right in front of you.
  ballPlayer.position.set(0, controls.userHeight - 30, -120.0);

// Add cube mesh to your three.js scene
  scene.add(ballPlayer);


  var manager = new THREE.LoadingManager();
  manager.onProgress = function ( item, loaded, total ) {
    console.log( item, loaded, total );
  };


  var loader2 = new THREE.OBJLoader( manager );
  loader2.load( 'models/pointer.obj', function ( object ) {
    object.traverse( function ( child ) {
      if ( child instanceof THREE.Mesh ) {
        child.material.map = texture;
      }
    } );
    pointer = object;
   object.position.set(ballPlayer.position.x,ballPlayer.position.y,ballPlayer.position.z);
    pointer.scale.set(5,5,5);
    pointer.rotation.z=Math.PI;

    scene.add( object );
  }, onProgress, onError  );


  document.addEventListener( 'mousemove', onDocumentMouseMove, false );


  /*
   glm::vec3 cameraPos[5]={glm::vec3(10.0f, 120.0f, -120.0f),glm::vec3(0.0f, -30.0f, 25.0f),glm::vec3(0.0f, 0.0f, 10.0f),glm::vec3(0.0f, 35.0f, 150.0f),glm::vec3(0.0f,-100.0f,-100.0f)};
   glm::vec3 cameraView[5]={glm::vec3(0.0f, 0.0f, -1.0f),glm::vec3(1.0f,1.0f,1.0f),glm::vec3(0.0f, 0.0f, -10.0f),glm::vec3(0.0f, 0.0f, -1.0f),glm::vec3(0.0f,0.0f,-100.0f)};
   glm::vec3 cameraUp[5]={glm::vec3(0.0f, 1.0f, 1.0f),glm::vec3(0.0f, 1.0f, 1.0f),glm::vec3(0.0f, 1.0f, 1.0f),glm::vec3(0.0f, 1.0f, 1.0f),glm::vec3(0.0f, 1.0f, 1.0f)};


   //RUI barra cima
   display_at(1, -35.0f, 75.0f, 0.0f,0.0f,0.0f, -1.0f, 1.0f,70.0f,2.0f,2.0f);

   //RUI barra esq
   display_at(1, -35.0f, -10.0f, 0.0f,0.0f,0.0f, -1.0f, 1.0f,2.0f,85.0f,2.0f);
   //RUI barra dir
   display_at(1, 33.0f, -10.0f, 0.0f,0.0f,0.0f, -1.0f, 1.0f,2.0f,87.0f,2.0f);



   //dispx+=0.00035f;
   //RUI - GLOBE
   display_at(2, dispx, -dispx, -100.0f, 1.0f,1.0f, 1.0f, 1.0f,100.0f,100.0f,100.0f);

   */

  var listener = new THREE.AudioListener();
  camera.add( listener );


  var audioLoader = new THREE.AudioLoader();

  var sound1 = new THREE.PositionalAudio( listener );
  audioLoader.load( 'sound/po.ogg', function( buffer ) {
    sound1.setBuffer( buffer );
    sound1.setRefDistance( 20 );
    sound1.play();
  });
  camera.add( sound1 );
  sound1.position.z = 1;
  sound1.position.x = 1;
  sound1.position.y = 1;

  analyser = new THREE.AudioAnalyser( sound1, 32 );


  directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
  directionalLight.position.set( 0, 1, 0 );
  scene.add( directionalLight );

  directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
  directionalLight.position.set( 1, 0, 1 );
  scene.add( directionalLight );

  //light = new THREE.AmbientLight( 0x404040 ); // soft white light
  light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );; // soft white light
  scene.add( light );


  // For high end VR devices like Vive and Oculus, take into account the stage
  // parameters provided.
  setupStage();
}


// Create a VR manager helper to enter and exit VR mode.
var params = {
  hideButton: false, // Default: false.
  isUndistorted: false // Default: false.
};
var manager = new WebVRManager(renderer, effect, params);



// Kick off animation loop
requestAnimationFrame(animate);

window.addEventListener('resize', onResize, true);
window.addEventListener('vrdisplaypresentchange', onResize, true);

// Request animation frame loop function
var lastRender = 0;


function onResize(e) {


  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  effect.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

var display;

// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length > 0) {
      display = displays[0];
      if (display.stageParameters) {
        setStageDimensions(display.stageParameters);
      }
    }
  });
}

function setStageDimensions(stage) {
  // Make the skybox fit the stage.
  var material = skybox.material;
  scene.remove(skybox);

  // Size the skybox according to the size of the actual stage.
  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
  skybox = new THREE.Mesh(geometry, material);

  // Place it on the floor.
  skybox.position.y = boxSize/2;
  scene.add(skybox);


}
  function onDocumentMouseMove( event ) {
    mouseX = ( event.clientX - windowHalfX ) / 2;
    mouseY = ( event.clientY - windowHalfY ) / 2;
  }

  function animate(timestamp) {

    var _time = Date.now();

    var delta = Math.min(timestamp - lastRender, 500);
    lastRender = timestamp;

    // Apply rotation to cube mesh
    if (analyser !== undefined )
      directionalLight.color = new THREE.Color(
              Math.cos(_time * 0.0005) +(analyser.getData()[ 4 ] / 200),
              Math.sin(_time * 0.0005) + (analyser.getData()[ 8 ] / 200),
              0
      );

    if (ballPlayer){

      ballPlayer.rotation.y += delta * 0.0006 ;
      ballPlayer.material.color = new THREE.Color(Math.cos(_time * 0.005 ),Math.sin(_time * 0.005) ,(Math.cos(_time * 0.005 ) + Math.sin(_time * 0.005 ))/2);
      ballPlayer.scale.set( 1+ (analyser.getData()[ 4 ] / 128),1+(analyser.getData()[ 4 ] / 128), 1+ (analyser.getData()[ 4 ] / 128));
    }

    if ( pointer && mouseX ){
      pointer.rotation.z = Math.PI - mouseX/windowHalfX*2;
      pointer.scale.set( 5 * ( 1 + (analyser.getData()[ 4 ] / 128) ), 5 * (1+(analyser.getData()[ 4 ] / 128)), 5 *(1 + (analyser.getData()[ 4 ] / 128)));

      console.log(mouseX);
    }

    // Update VR headset position and apply to camera.
    controls.update();

    // Render the scene through the manager.
    manager.render(scene, camera, timestamp);

    requestAnimationFrame(animate);
  }

</script>

</html>
